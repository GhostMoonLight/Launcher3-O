##GC算法 垃圾收集器

http://liuwangshu.cn/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/

####对象判断存活
    判断对象存活的一般有两种方式：
        引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，
                 计数为0时可以回收。此方法简单，无法解决对象相互循环引用 的问题。 
        可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。
                    当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
        在java语言中GC Roots包括：
            虚拟机栈中引用的对象
            方法区中类静态属性实体引用的对象
            方法区中常量引用的对象
            本地方法栈中JNI引用对象

####运行时数据区域
    1. 程序计数器：
            程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器
            当前线程私有
            此内存区域是唯一 一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 
    2. 虚拟机栈：
            线程私有，生命周期与线程相同
            存储方法的局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息。
            java方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
            StackOverflowError异常：当线程请求的栈深度大于虚拟机所允许的深度
            OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存
    3. 本地方法栈：
            与虚拟机栈相似，主要为虚拟机使用到的Native方法服务
    4. 堆：
            当前线程所执行的字节码的行号指示器
            当前线程私有
            OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时。
    5. 方法区：
            方法区用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
            当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 
    6. 常量池：
            它是方法区的一部分。
            用于存放编译期生成的各种字面量与符号引用，如String类型常量就存放在常量池
            当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
            
            
####java堆是垃圾收集器管理的主要区域 